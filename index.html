<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <link rel="stylesheet" href="style.css"/>
    <title>Dragging Nodes and Alpha Values</title>
</head>

<style>
    body {
        margin: 0;
        background: #eee;
    }

    /* .svg-container {
        display: inline-block;
        position: relative;
        width: 100%;
        padding-bottom: 100%;
        vertical-align: top;
        overflow: hidden;
    }

    .svg-content {
        display: inline-block;
        position: absolute;
        top: 0;
        left: 0;
    } */

    g {
        opacity: 0.6;
        transition: opacity 0.2s ease-in-out;
        overflow: visible;
        cursor: default;
    }

    g:hover {
        opacity: 1;
    }

    g div {
        height: 60px;
        width: 120px;
        padding: 10px;
        background: #fff;
        text-align: center;
        vertical-align: middle;
        white-space: pre;
        visibility: hidden;
        border-radius: 10px;
        box-shadow: 0 0 6px rgba(0, 0, 0, 0.6);
    }

    .controls {
        visibility: visible;
    }

    g:hover div {
        visibility: visible;
    }

    /*
        g image {
            visibility: hidden;
        }

        g:hover image {
            visibility: visible;
        } */
</style>

<body>
<div id="container" class="svg-container">
    <!-- <svg
            class="svg-content"
            version="1.1"
            baseProfile="full"
            xmlns="http://www.w3.org/2000/svg"
            preserveAspectRatio="xMidYMid meet"
    ></svg> -->
</div>

<!-- DONT NEED? * TODO: 1. scale drawing to 90% of viewport (vertically and horizontally) -->
<!-- DONE TODO: 2. add permanent labels to nodes -->
<!-- DONE TODO: 3. add permanent icons to nodes (any image url is fine for now)-->
<!-- DONT NEED TODO: 4. allow for triangle or rectangular shapes in nodes -->
<!-- DONE ** TODO: 5. add on-hover text (show metadata when hovering over) -->
<!-- TODO: 6. add dynamic text above node (gets updated constantly from backend) -->
<!-- TODO: 7. add dynamic images/drawings/animation along links (gets updated constantly from backend) -->
<!-- DONT KNOW TODO: 8. change forces so the more force between nodes given more degrees of separation/freedom -->
<!-- TODO: 9. allow user to toggle on/off nodes self-separating - default is on - if it's off: then user can drag nodes wherever they want  -->
<!-- ** TODO: 11: on-hover over link -> show histogram -->
<!-- TODO: 12: create a control panel that can do the following:-->
<!--    * button to toggle physics on/off for the graph-->
<!--    * pause/unpause button (to pause a process on backend-->
<!--    * button to slow-down or speed-up backend process (change timestep) -->
<!--    * button to stop all sources (stop generating new consumables/movables on the backend)-->
<!-- DONE ** TODO: 10: on-click node -> show histogram -->
<!-- ** TODO: 11: code histogram into metadata toggle -->
<!-- TODO: 13: control panel at top: movable -->
<!-- TODO: 14: create generic JSON editor panel - show JSON blob and allow user to edit and save it (there should be ready-made solutions for this)-->



<!-- TODO:make initial separating force a little stronger, so that nodes are further apart (more spaced out). -->
<!-- TODO:2. on/in initial render, avoid crossing lines/edges -->
<!-- TODO: 3. avoid crossing links - https://stackoverflow.com/questions/74453071/avoid-crossing-links -->
<!-- TODO: 4. rendering is optimization problem, roughly: -->
<!--       * minimize link crossing/overlap. -->
<!--       * maximize space between nodes. -->
<!--       * but keep drawing within container.-->

<!--we are using version 7 of d3, use the minified version later -->
<script src="https://d3js.org/d3.v7.js"></script>

<script>

    const client = new WebSocket('ws://0.0.0.0:5900');

    client.addEventListener('message', m => {
        console.log('change event:', m);
        location.reload(); // reload page
    });

    client.addEventListener('error', e => {
        console.log('start ws server using start.js in the project root to get live updates.')
    });

    const program = {
        ctrlKey: false,
        metaKey: false
    };

    document.onkeydown = (event) => {
        if (event.key === 'Control') {  // this doesn't really seem to work
            program.ctrlKey = true;
        }
        if (event.key === 'Meta') {
            program.metaKey = true;
        }
        // console.log({program});
    };

    document.onkeyup = (event) => {
        if (event.key === 'Control') {  // this doesn't really seem to work
            program.ctrlKey = false;
        }
        if (event.key === 'Meta') {
            program.metaKey = true;
        }
        // console.log({program});
    };

    const fisherYatesShuffle = function* (deck) {
        for (let i = deck.length - 1; i >= 0; i--) {
            const swapIndex = Math.floor(Math.random() * (i + 1));
            [deck[i], deck[swapIndex]] = [deck[swapIndex], deck[i]];
            yield deck[i];
        }
    };

    const colors = [
        'red',
        'blue',
        'brown',
        'indigo',
        'purple',
        'orange',
        'pink',
        'yellow',
        'maroon',
        'black',
        'magenta',
        'green',
        'gray',
        'violet'
    ];


    const width = window.innerWidth;
    const height = window.innerHeight;
    const minRadius = 20;
    // I just made up a formula, but radius should be a function of window size
    // (and eventually number of nodes as well)
    const nodeRadius = Math.max(minRadius, Math.floor(Math.min(width, height) / 25));
    // console.log("node radius: " + nodeRadius);

    let histogramShowing = false;

    const placeLabelsAndIcons = () => {
        const svg = d3.select("svg");

        if (!svg) {
            console.error('missing svg element.');
            return;
        }

        svg.selectAll("text").remove();
        svg.selectAll("image").remove();
        svg.selectAll("foreignObject").remove();

        const gs = svg.selectAll("g")
            .on('click', d => {
                //TODO: kind of a kludge here, there must be a way to access it cleaner?
                d.target.__data__.histogramShowing = !d.target.__data__.histogramShowing;
                // console.log(d.target.__data__.histogramShowing)
                // console.log(d3.select(this).histogramShowing)
                // d3.select(this).histogramShowing = true
                // d3.select(this)
                //     .style('background', '#ddd')
            });

        // svg.selectAll("g").on("click", d => { console.log("Clicked " + d.histogramShowing); });

        gs.append("image")
            .attr("x", d => d.x - d.size)
            .attr("y", d => d.y - 1.8 * d.size)
            .attr("width", d => d.size / 2)
            .attr("height", d => d.size / 2)
            .attr("href", d => d.iconUrl);

        // gs.append("text")
        // 	.attr("x", d => d.x + d.size / 2)
        // 	.attr("y", d => d.y - 1.9 * d.size)
        // 	.attr("text-anchor", "middle")
        // 	.text(d => 'ID: ' + d.id);

        gs.append("text")
            .attr("x", d => d.x + d.size / 3)
            .attr("y", d => d.y - 1.5 * d.size)
            .attr("text-anchor", "middle")
            .text(d => 'Name: ' + d.name);

        // gs.append("text")
        // 	.attr("x", d => d.x + d.size / 2)
        // 	.attr("y", d => d.y - 1.1 * d.size)
        //     .attr("text-anchor", "middle")
        // 	.text(d => 'Label: ' + d.label);

        gs.append("foreignObject")
            .attr("x", d => d.x - 70)
            .attr("y", d => d.y + 1.1 * d.size)
            .style("overflow", "visible")
            // .append(Histogram(d => d.histogram, {
            //     value: d => d.value,
            //     label: 'histogram data',
            //     width: 120,
            //     height: 60,
            //     color: "steelblue"
            // }))
            .append("xhtml:div")
            .text(d => d.histogramShowing ? "histogram" : "ID: " + d.id + "\nName: " + d.name + '\nLabel: ' + d.label);

    };

    const run = (nodes, links) => {

        setTimeout(() => {

            // TODO: dynamically add a new node/link
            // TODO: this doesn't work yet :/
            return;

            // dynamically add a new node
            nodes.push({
                color: colors[colorIndex++ % nodes.length],
                size: nodeRadius,
                label: 'Z',
                name: 'Z',
                id: 'Z',
                iconUrl: 'https://raw.githubusercontent.com/ORESoftware/d3-front-end/main/images/server-node.svg',
                histogram: [{value: 20}, {value: 30}, {value: 40}],
                histogramShowing: false
            });
            // dynamically add a new link
            links.push({
                source: 'Z',
                target: 'E'
            });
        }, 5000);

        setInterval(() => {
            for (const n of fisherYatesShuffle(nodes)) {
                // update node with id = n.id
                // TODO: dynamically update nodes in network here
                // TODO: down the line, will be updated with websocket conn
            }

            // placeLabelsAndIcons();
        }, 2000);

        const svg = d3.select('div#container')
            .append('svg')
            .attr("viewBox", "0 0 " + window.innerWidth + " " + window.innerHeight)
        // .classed("svg-content", true);

        // let svg = d3
        //     .select("svg")
        //     .attr("width", width)
        //     .attr("height", height);

        // svg.append("foreignObject")
        //         .attr("x", 100)
        //         .attr("y", 100)
        //         .style("overflow", "visible")
        //         // .append(Histogram(d => d.histogram, {
        //         //     value: d => d.value,
        //         //     label: 'histogram data',
        //         //     width: 120,
        //         //     height: 60,
        //         //     color: "steelblue"
        //         // }))
        //         .append("xhtml:div")
        //         .classed('controls', true)
        //         .text("histogram"); 

        // append a path marker to svg defs
        svg.append("defs").selectAll("marker")
            .data(["dominating"])
            .enter().append("marker")
            .attr("id", d => d)
            .attr("viewBox", "0 -5 10 10")
            .attr("refX", 0)
            .attr("refY", 0)
            .attr("markerWidth", 12)
            .attr("markerHeight", 12)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M0,-5L10,0L0,5");

        let linkSelection = svg
            .selectAll("line")
            .data(links)
            .enter()
            .append("line")
            .attr("stroke", "black")
            .attr("stroke-width", 1)
            // add marker to line
            .attr("marker-end", d => "url(#dominating)");


        let nodeSelection = svg
            .selectAll("circle")
            .data(nodes)
            .enter()
            .append("g")
            .append("circle")
            .attr("r", d => d.size)
            .attr("fill", d => d.color)
            .attr("img", d => d.icon)
            .call(
                d3
                    .drag()
                    .on("start", dragStart)
                    .on("drag", drag)
                    .on("end", dragEnd)
            );

        let simulation = d3.forceSimulation(nodes);

        simulation
            .force("center", d3.forceCenter(width / 2, height / 2))
            .force("nodes", d3.forceManyBody())
            .force("radial", d3.forceRadial(height, width / 2, height / 2))
            .force("charge", d3.forceManyBody().strength(-30 * nodeRadius)) // repulsion should scale with node size
            .force("collision", d3.forceCollide().radius(nodeRadius / 2))
            // .force('collide', d3.forceCollide().radius(function(d) {
            //     return d.radius + 150;
            // }))
            // .linkDistance(1)
            .force(
                "links",
                d3
                    .forceLink(links)
                    .id(d => d.id)
                    // .distance(d => 5 * (d.source.size + d.target.size))
                    // TODO force distance between all elements, not just connected ones
                    // TODO in fact, force should be greater amongst non-connected elements
                    // TODO idea - force should increase as degree of freedom between nodes increases
                    .distance((d, a, b) => {
                        // console.log({d, a, b});
                        return 3 * (d.source.size + d.target.size);
                    })
            )
            .on("tick", ticked);

        // data.nodes contains all nodes
        // for(let i = 0; i < nodes.length - 1; i++) {
        //     for(let j = i + 1; j < nodes.length; j++) {
        //         simulation.force();
        //     }
        // }

        function ticked() {
            // console.log(simulation.alpha());

            nodeSelection.attr("cx", d => d.x).attr("cy", d => d.y);

            linkSelection
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);


            // recalculate and back off the distance
            linkSelection.each(function (d, i, n) {
                // current path length
                const pl = this.getTotalLength();
                // radius of marker head plus def constant
                const mrs = (d.source.size);
                const mrt = (d.target.size) + 12;
                // get new start and end points
                const m1 = this.getPointAtLength(mrs);
                const m2 = this.getPointAtLength(pl - mrt);
                // new line start and end
                d3.select(n[i])
                    .attr("x1", m1.x)
                    .attr("y1", m1.y)
                    .attr("x2", m2.x)
                    .attr("y2", m2.y);
            });

            placeLabelsAndIcons();
        }

        function dragStart(event, d) {
            // console.log('drag start');
            simulation.alphaTarget(0.5).restart();
            d.fx = d.x;
            d.fy = d.y;
            placeLabelsAndIcons();
        }

        function drag(event, d) {
            // console.log('dragging', event, d);
            // simulation.alpha(0.5).restart()
            d.fx = event.x;
            d.fy = event.y;
            placeLabelsAndIcons();
            // d.fx = d3.event.x;
            // d.fy = d3.event.y;
        }

        function dragEnd(event, d) {
            // console.log('drag end');
            placeLabelsAndIcons();
            simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
            placeLabelsAndIcons();
        }
    }


    const nodes = [];
    const links = [];

    let colorIndex = nodes.length - 1;

    const data = {
        formation: [
            {
                "name": "A",
                "id": "A",
                "entity": {
                    "initialGraphData": true
                },
                "iconUrl": "https://oyster.ignimgs.com/mediawiki/apis.ign.com/new-super-mario-bros-u/4/48/Yoshi.png",
                "label": "A",
                "connectionsOut": [
                    "B", "C"
                ]
            },
            {
                "name": "F",
                "id": "F",
                "entity": {
                    "initialGraphData": true
                },
                "iconUrl": "https://oyster.ignimgs.com/mediawiki/apis.ign.com/new-super-mario-bros-u/4/48/Yoshi.png",
                "label": "F",
                "connectionsOut": [
                    "C"
                ]
            },
            {
                "name": "B",
                "id": "B",
                "entity": {
                    "initialGraphData": true
                },
                "iconUrl": "https://oyster.ignimgs.com/mediawiki/apis.ign.com/new-super-mario-bros-u/4/48/Yoshi.png",
                "label": "B",
                "connectionsOut": [
                    "C"
                ]
            },
            {
                "name": "C",
                "id": "C",
                "entity": {
                    "initialGraphData": true
                },
                "iconUrl": "https://oyster.ignimgs.com/mediawiki/apis.ign.com/new-super-mario-bros-u/4/48/Yoshi.png",
                "label": "C",
                "connectionsOut": [
                    "D"
                ]
            },
            {
                "name": "D",
                "id": "D",
                "entity": {
                    "initialGraphData": true
                },
                "iconUrl": "https://oyster.ignimgs.com/mediawiki/apis.ign.com/new-super-mario-bros-u/4/48/Yoshi.png",
                "label": "D",
                "connectionsOut": [
                    "E"
                ]
            },
            {
                "name": "E",
                "id": "E",
                "entity": {
                    "initialGraphData": true
                },
                "iconUrl": "https://oyster.ignimgs.com/mediawiki/apis.ign.com/new-super-mario-bros-u/4/48/Yoshi.png",
                "label": "E",
                "connectionsOut": []
            },

        ]
    }



    if (data.formation) {
        for (const z of data.formation) {

            nodes.push({
                color: colors[colorIndex++ % nodes.length],
                size: nodeRadius,
                label: z.label,
                name: z.name,
                id: z.id,
                iconUrl: z.iconUrl,
                histogram: [{value: 20}, {value: 30}, {value: 40}],
                histogramShowing: false
            });

            // we only need-be concerned with connectionsOut, not connectionsIn, in order to complete graph
            for (const targetId of z.connectionsOut) {
                links.push({source: z.id, target: targetId, ...{whatever: 'else'}});
            }
        }

        // for (const v of nodes) {
        //   console.log(v);
        // }
        //
        // for (const v of links) {
        //   console.log(v);
        // }

        run(nodes, links);
    }


</script>
</body>
</html>

